<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>using certificates properly with requests library in python</title>
</head>
<body>
    <h1>Author: ganesh</h1>
    <h2>Date: 2023-05-04</h2>
    <div><p>Whenever we try to access a “https” website with the requests library, it usually uses openssl toolkit (atleast on linux. not sure about windows) for establishing a secure connection.</p>
<p>The OpenSSL toolkit on linux does not any, by default, have any trusted “root certificates”. check <a href="https://support.mozilla.org/en-US/kb/secure-website-certificate">this link</a> for more information on how TLS certificates are validated.</p>
<p>Because of this requests library fails to verify the authenticity of the server and throws an error like this:</p>
<pre><code>certificate verify failed: unable to get local issuer certificate</code></pre>
<p>To fix this, we’d need to tell openssl where to look for trusted certificates - this is done by CApath argument which specifies the directory containing the trusted certificates. Lets assume the trusted certificates are stored in <code>crts</code> directory (you can get a list of good ones <a href="https://ccadb.my.salesforce-sites.com/mozilla/CACertificatesInFirefoxReport">here</a>).</p>
<p>We can use <code>openssl</code> cli tool to test if TLS verification is working properly. But it expects the names in <code>crts</code> to follow a specific pattern. This can be generated automatically from existing crts:</p>
<p><code>openssl rehash ./crts</code></p>
<p>After this:</p>
<p><code>openssl s_client -CApath crts -connect hostname:443</code></p>
<p>If everything works, you should see something like this:</p>
<pre><code>SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: EB6EF7EBC5A64DA06BF2A073DF528E46B80B7775AC0E58BB07C66B09DF280037
    Session-ID-ctx: 
    Master-Key: 9B83F583A61D7A5F74B3DCD9DABB0414A3E686D98BD297174B189EC57B8123BC221AA37C2ED2DAFD19E5FF6F6F27D468
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    Start Time: 1680743449
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok) #this tells us if verification succeded
    Extended master secret: no</code></pre>
<p>If the certificate validation fails (you can omit the <code>CApath</code> argument and try the same command), the output will be something like this:</p>
<pre><code>SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: 2E98282E75BB099F1483C75AE713874E78B0629F8DA052C6D4597AF20E2E0037
    Session-ID-ctx: 
    Master-Key: AFB17089810371B424B25F1353B343C4647242613AE442664641D1AFA448587E95CDAA474F666ECB0DE509553D2ED0B6
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    Start Time: 1680743462
    Timeout   : 7200 (sec)
    Verify return code: 21 (unable to verify the first certificate) #failed!!
    Extended master secret: no</code></pre>
<p>Note: Ideally, a server should send all intermediary certificates to the client so that the chain is complete. But many websites do not do this - because of this the crts directory should have intermediate certificates also. This is not a problem when using web-browsers because they automatically download the missing certificates. I did not have time to find if the requests library/openssl cli tool also has this option.</p>
<p>Now since we verified that certificate chain is being validated properly, we can give the crts directory path to a request session:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>session <span class="op">=</span> requests.session()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>session.verify <span class="op">=</span> <span class="st">&quot;./crts&quot;</span></span></code></pre></div>
</div>
</body>
</html>